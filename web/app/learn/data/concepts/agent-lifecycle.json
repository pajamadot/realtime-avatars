{
  "id": "agent-lifecycle",
  "title": "LiveKit Agent Lifecycle",
  "level": 2,
  "parentConcept": "livekit-agents",

  "explanation": {
    "level3Assumes": "You understand that LiveKit Agents orchestrate voice AI, but not the detailed lifecycle of an agent from startup to shutdown.",
    "thisExplains": "The complete lifecycle of a LiveKit agent: worker registration, job dispatch, session management, and graceful shutdown.",
    "text": "A LiveKit Agent goes through distinct phases from startup to shutdown. Understanding this lifecycle is crucial for production deployments.\n\n**The Complete Lifecycle:**\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    AGENT LIFECYCLE                       │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  1. STARTUP                                             │\n│     Worker registers with LiveKit Cloud                 │\n│                    ↓                                    │\n│  2. IDLE                                                │\n│     Worker waits for job dispatch                       │\n│                    ↓                                    │\n│  3. JOB ASSIGNED                                        │\n│     Worker receives job, connects to room               │\n│                    ↓                                    │\n│  4. SESSION ACTIVE                                      │\n│     Agent processes audio, generates responses          │\n│                    ↓                                    │\n│  5. SESSION END                                         │\n│     Participant leaves or timeout                       │\n│                    ↓                                    │\n│  6. CLEANUP                                             │\n│     Release resources, return to IDLE                   │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n**Phase 1: Worker Startup**\n\n```python\nif __name__ == \"__main__\":\n    cli.run_app(\n        WorkerOptions(\n            entrypoint_fnc=entrypoint,\n            # Worker configuration\n            num_idle_processes=2,  # Pre-fork for fast dispatch\n            shutdown_process_timeout=30,\n        )\n    )\n```\n\nThe worker:\n1. Connects to LiveKit Cloud via WebSocket\n2. Registers capabilities (which room types it handles)\n3. Reports health status periodically\n4. Pre-forks processes for fast job acceptance\n\n**Phase 2: Job Dispatch**\n\nWhen a participant joins a room requesting an agent:\n\n```\nParticipant joins room\n        ↓\nLiveKit Cloud checks dispatch rules\n        ↓\nFinds available worker with matching capabilities\n        ↓\nSends job assignment to worker\n        ↓\nWorker accepts/rejects within timeout\n```\n\n**Phase 3: Job Context**\n\n```python\nasync def entrypoint(ctx: agents.JobContext):\n    # ctx contains:\n    #   - ctx.room: The LiveKit room connection\n    #   - ctx.job: Job metadata (room name, participant info)\n    #   - ctx.proc: Process information\n    \n    # Connect to room\n    await ctx.connect()  # Establishes WebRTC connection\n    \n    # Now you can:\n    #   - Subscribe to participant tracks\n    #   - Publish your own tracks\n    #   - Send data messages\n```\n\n**Phase 4: Session Management**\n\n```python\nasync def entrypoint(ctx: agents.JobContext):\n    await ctx.connect()\n    \n    # Create agent session\n    session = AgentSession(\n        llm=openai.realtime.RealtimeModel(),\n        vad=silero.VAD.load(),\n    )\n    \n    # Create agent with instructions\n    agent = MyAgent(instructions=\"You are helpful...\")\n    \n    # Start the session\n    await session.start(\n        room=ctx.room,\n        agent=agent,\n        participant=ctx.job.participant,  # Which participant to listen to\n    )\n    \n    # Session runs until participant leaves or error\n```\n\n**Session Events:**\n\n```python\n@session.on(\"user_speech_started\")\nasync def on_speech_start():\n    # User started talking\n    pass\n\n@session.on(\"agent_speech_started\")\nasync def on_agent_speech():\n    # Agent is responding\n    pass\n\n@session.on(\"conversation_item_added\")\nasync def on_new_item(item):\n    # New conversation turn\n    pass\n```\n\n**Phase 5: Graceful Shutdown**\n\n```python\nasync def entrypoint(ctx: agents.JobContext):\n    await ctx.connect()\n    \n    # Register cleanup handler\n    @ctx.on(\"disconnected\")\n    async def on_disconnect():\n        # Clean up avatar session\n        await avatar_session.close()\n        # Release any resources\n        await cleanup_resources()\n    \n    session = AgentSession(...)\n    await session.start(...)\n    \n    # Wait for session to end naturally\n    await session.wait_for_close()\n```\n\n**Error Handling:**\n\n```python\nasync def entrypoint(ctx: agents.JobContext):\n    try:\n        await ctx.connect()\n        session = AgentSession(...)\n        await session.start(...)\n    except agents.JobCancelledError:\n        # Job was cancelled externally\n        logger.info(\"Job cancelled\")\n    except Exception as e:\n        # Unexpected error\n        logger.error(f\"Agent error: {e}\")\n        # Report error to monitoring\n        metrics.record_error(e)\n    finally:\n        # Always cleanup\n        await cleanup()\n```\n\n**Scaling Considerations:**\n\n```python\nWorkerOptions(\n    # Number of jobs this worker can handle\n    num_idle_processes=5,\n    \n    # Memory limits per job\n    job_memory_warn_mb=500,\n    job_memory_limit_mb=1000,\n    \n    # Timeout for job acceptance\n    job_request_timeout=10,\n    \n    # Graceful shutdown timeout\n    shutdown_process_timeout=30,\n)\n```\n\n**Health Monitoring:**\n\n```python\n# Worker reports to LiveKit Cloud:\n# - CPU usage\n# - Memory usage\n# - Active job count\n# - Job success/failure rates\n# - Average response latency\n```"
  },

  "visual": {
    "type": "interactive",
    "demoId": "agent-lifecycle",
    "caption": "Trace through the agent lifecycle: see state transitions, events, and cleanup in action."
  },

  "prerequisites": [
    "async-programming",
    "websockets"
  ],

  "insight": "A LiveKit Agent is like a restaurant chef: it registers availability, gets assigned tables (jobs), serves customers (participants), then cleans up and waits for the next assignment."
}
